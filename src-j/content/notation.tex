\begin{newj}
Thus far, we have intuitively introduced the concepts of events, (partial) cases, (partial) traces, event logs and related aspects.
In this section, we delve deeper into these notions from a formal standpoint. The definitions provided henceforward pave the ground for properties and aspects to which we will resort in the design and realization of our solution.

\begin{definition}[Event]\label{def:evt}
	Let $\EvtU \ni \Evt$ be a finite non-empty set of symbols. We refer to $\Evt$ as \emph{event} and to $\EvtU$ as the \emph{universe of events}.
	An \emph{attribute} is a function having the universe of events as its domain.
\end{definition}
%
%In the example, $\Evt=\{\texttt{312},\ \texttt{2022-07-14T10:36},\ \texttt{PH}\}$ represents the event occurring when Alice's hospitalization journey begins. An attribute is a generic function that returns one or more symbols of $\Evt$.\todo{Add example.Done}
Referring to the example of Alice and Bob's hospitalization process, each generic event denoted as $\Evt_i$ within \cref{Tab:traces} is contained in the universe of events $\EvtU$. Due to the general nature of elements that can be linked to events via the attribute function, we leave the range unspecified, akin to the definition of finite sequence as a function in \cite{Mendelson/2015:IntroductionMathematicalLogic}. We assume the following attributes as mandatory, though, as in the classical process mining literature~\cite{Aalst/2016:ProcessMiningBook:DataScienceinAction}. \todo{Add example.Done}
%
\begin{assumption}[Mandatory attributes]\label{asm:attribute}
	The following attributes are total on the universe of events $\EvtU$:
	\begin{inparadesc}
		\item[inter-organizational instance identifier] (or {\CId} for short), a total surjective function $\CIdF : \EvtU \to \CIdU$, where $\CIdU$ is a finite non-empty set we name \emph{instance set};
		\item[activity label\textnormal{,}] a total function $\ActF : \EvtU \to \ActS$, where $\ActS$ is a finite non-empty set we name \emph{activity set};
		\item[timestamp\textnormal{,}] a total function $\TimeF : \EvtU \to \mathbb{N}$, where $\mathbb{N}$ is the set of positive integers.
	\end{inparadesc}
\end{assumption}
%
%Considering the event $\Evt_1$ of our motivating scenario, the {\CIdF} function computed over this event returns the identifier 312, which groups the events constituting Alice's hospitalization in the three organizations. Similarly, the function applications {$\ActF(\Evt_1)$} and the {$\TimeF(\Evt_1)$} link $\Evt_i$ to its activity label (i.e., \texttt{PH}) and its timestamp (i.e., \texttt{2022-07-14T10:36}), respectively.
In the context of our motivating scenario, when examining the event $\Evt_1$ in \cref{Tab:traces}, the {\CIdF} function yields the inter-organizational identifier 312. This id serves to collate the events associated with Alice's hospitalization across the three organizations. Furthermore, the function applications {$\ActF(\Evt_1)$} and {$\TimeF(\Evt_1)$} establish connections between $\Evt_1$ and its activity label (i.e., \texttt{PH}) and timestamp (i.e., \texttt{2022-07-14T10:36}), respectively.
\todo{Add example.Done}
%
\begin{definition}[Event log]\label{def:evt:log}
	Given the universe of events $\EvtU$ as per \cref{def:evt}, let ${\prec \;\subseteq\; \EvtU \times \EvtU}$ be a strict total-order relation defined over $\EvtU$.
	The pair $\left( \EvtU, \prec \right)$ is an \emph{event log}.
\end{definition}
In our illustrative example, we exemplify the event log $(\EvtU,\prec)$ as the totally ordered set comprehensive of all the events $\Evt_1 \dots \Evt_{31}$ recorded by the \Actor{Hospital}, the \Actor{Pharmaceutical company}, and the \Actor{Specialized clinic}.\todo[]{Add comment.Done}
%
\begin{assumption}[Timestamp as an order isomorphism]\label{asm:order:timestamp}
	Given an event log $\left( \EvtU, \prec \right)$, the timestamp attribute $\TimeF: \EvtU \to \mathbb{N}$ is an \textit{order isomorphism}, i.e., given $\Evt, \Evt' \in \EvtU$ with $\Evt \neq \Evt'$, $\Evt \prec \Evt'$ if and only if $\TimeF(\Evt) < \TimeF(\Evt')$.
\end{assumption}
%
Examining the events $\Evt_{1}$ and $\Evt_{31}$ within our motivating scenario, we can deduce from the order relation established based on their timestamp attributes (i.e., \texttt{2022-07-14T10:36} and \texttt{2022-07-16T05:06}, respectively) that $\Evt_{1}$ precedes $\Evt_{31}$. Consequently, ${\Evt_1}\prec{\Evt_{31}}$. This rationale holds true for any generic pair of events selected from the event log.\todo[]{Add example.Done.}
%

In our setting, events may be recorded by different entities. We name these entities \emph{provisioners} and formally define them as follows.
\begin{definition}[Provisioner]\label{def:provisioner}
	$\LPrvS = \{ \LPrv_1, \ldots, \LPrv_n \}$ is a non-empty finite set of entities (with $n \in \mathbb{N}$) we name \emph{provisioner}s. 
	Given an event $\Evt \in \EvtU$ as per \cref{def:evt}, $\PartMap$ is a total surjective function over the domain of events $\EvtU$ and the range $\LPrvS$ of provisioners. Function $\PartMap$ defines an equivalence relation $\PartEq$ on $\EvtU$ (i.e., $\Evt \PartEq \Evt'$ iff $\Evt \PartMap \LPrv$ and $\Evt' \PartMap \LPrv$) and hence partitions $\EvtU$ into equivalence classes we denote with $\EqCls{\LPrv}$ for every $\LPrv \in \LPrvS$.
\end{definition}
In the depicted scenario, we introduce three provisioners: the \Actor{Hospital}, the \Actor{Pharmaceutical company}, and the \Actor{Specialized clinic}  referred to as ($\LPrv_1$), ($\LPrv_2$), and ($\LPrv_3$) for purposes of exemplification. Events $\Evt_{1}$ and $\Evt_{20}$ fall within the same equivalence class $\EqCls{\LPrv_1}$ as they are both recorded by the \Actor{Hospital}. Consequently, the relation $\Evt_1 \PartEq \Evt_{20}$ holds true. Conversely, $\Evt_{1}$ and $\Evt_{31}$ are recorded by the \Actor{Hospital} and the \Actor{Specialized clinic}, respectively, placing them in distinct equivalence classes, namely $\EqCls{\LPrv_1}$ and $\EqCls{\LPrv_3}$. Therefore, the relation $\Evt_1 \PartEq \Evt_{31}$ does not hold in this instance.
\todo{Add examples.Done.} 

\begin{definition}[Log partition]\label{def:partition}
	Given an event log $\left( \EvtU, \prec \right)$ as per \cref{def:evt:log}, provisioner $\LPrv \in \LPrvS$ and the equivalence class $\EqCls{\LPrv}$ as per \cref{def:provisioner}, a \emph{log partition} is a pair $\left( \EqCls{\LPrv}, \prec_\LPrv \right)$, where $\prec_\LPrv$ is the restriction of the total order $\prec$ over the elements in $\EqCls{\LPrv} \subseteq \EvtU$, i.e., $\;\prec_\LPrv$ is $(\prec) \cap (\EqCls{\LPrv} \times \EqCls{\LPrv})$.
\end{definition}
%
In our example, we posit that each organization independently maintains its own log partition. The events  $\Evt_{1}, \Evt_{2} \ldots \Evt_{20}$ associated with the equivalence class $\EqCls{\LPrv_{1}}$ are contained in the hospital's log partition  $\left( \EqCls{\LPrv_{1}}, \prec_{\LPrv_{1}} \right)$. Similarly, the two groups of events $\Evt_{21}, \Evt_{22} \ldots \Evt_{26}$ and $\Evt_{27}, \Evt_{28} \ldots \Evt_{31}$ constitue the elements of the \Actor{Pharmaceutical company} and the  \Actor{Specialized clinic} log partitions, namely,  $\left( \EqCls{\LPrv_{2}}, \prec_{\LPrv_{2}} \right)$ and  $\left( \EqCls{\LPrv_{3}}, \prec_{\LPrv_{3}} \right)$, respectively. We recall that the restriction of a totally ordered set (like the event log) is a total order. Therefore, the log partition is a totally ordered set, too. For instance, the relation $\Evt_1 \prec \Evt_2$ defined onto {\EvtU} implies that $\Evt_1 \prec_{\LPrv_{1}} \Evt_2$ is defined within $\EqCls{\LPrv_{1}}$. The same principle applies likewise to the restrictions $\prec_{\LPrv_{2}}$ and $\prec_{\LPrv_{3}}$ defined onto $\EqCls{\LPrv_{2}}$ and $\EqCls{\LPrv_{3}}$, respectively.
\todo{Add example}

\begin{definition}[Segment]\label{def:segment}
	Given a log partition $\left( \EqCls{\LPrv}, \prec_\LPrv \right)$ as per \cref{def:partition} and a subset of {\CId}s $\{\CId_i\}_{i \in [1,k]}$ (see \cref{def:evt}) with $k \leq |\CIdU|$, $k \in \mathbb{N}$, $\CId_i \in \CIdU$, a \emph{segment} $\Segm = \left( \EvtU_\Segm, \prec_\Segm \right)$ is a restriction of the log partition to all the events $\Evt_\Segm \in \EqCls{\LPrv}$ such that $\CIdF(\Evt') = \CId_i$ for any $\CId_i$ in the given subset. 
\end{definition}
%
In light of the above, the segment is a totally ordered set, too. Also, notice that a segment can be the whole log partition if the given set of {\CId}s contains all the {\CId}s to which the events in the log partition map. In the context of our example, when considering the \Actor{Pharmaceutical company}'s log partition $\left( \EqCls{\LPrv_{2}}, \prec_{\LPrv_{2}} \right)$, under every conceivable segmentation scenario, the events associated with Alice's hospitalization (i.e., $\Evt_{21}$, $\Evt_{23}$, and $\Evt_{25}$) consistently reside within the same segment \Segm'. Hence, any scenario wherein any two events pertaining to Alice's case are allocated to different segments (e.g., $\Evt_{21}$ in \Segm' and $\Evt_{23}$, $\Evt_{25}$ in \Segm'' respectively) is precluded by definition, as per \cref{def:segment}.  \todo{Add example.Done.} 


\begin{definition}[Merge]\label{def:merge}
	Let $(\EvtU, \prec)$ be an event log, and
	${\Segm' = (\EvtU_{\Segm'}, \prec_{\Segm'})}$,
	${\Segm'' = (\EvtU_{\Segm''}, \prec_{\Segm''})}$ two segments thereof as per \cref{def:segment}. 
	The \emph{merge} $\Merge$ is a binary operator computed as follows: 
	$\Segm' \Merge \Segm'' = \left(\EvtU_{\Segm'} \cup \EvtU_{\Segm''}, \prec_{\Merge} \right)$ 
	where 
	$\prec_{\Merge}$ is the restriction of $\prec$ over $\EvtU_{\Segm'} \cup \EvtU_{\Segm''}$, i.e.,  $\prec \cap\, \left(\EvtU_{\Segm'} \cup \EvtU_{\Segm''}\right) \times \left(\EvtU_{\Segm'} \cup \EvtU_{\Segm''}\right)$. 
\end{definition}
\todo[inline]{The preservation of the total order wrt the original log cannot be guaranteed if we have only two operands, namely the segments. We have to make it a property that only \emph{special} merges have. Surprise surprise, our function will do it by resorting to the timestamping.}
%
We remark that \textbf{BALSDLADBASDBLADBLADJASBDBAJSD}


\begin{comment}
def iid(event):
  bla bla bla
  
caseid = iid
hospitalcaseid = iid
treatmentid = iid

comesichiama = {"hospital" : "caseid", "pharma" : "hospitalcaseid", "clinic" : "treatmentid"}

comesichiama["hospital"](x)
\end{comment}
\begin{comment}
In light of the above, the log partition is a totally ordered set, too. In the example, \ldots\todo{Add example}
Let $\CIdU$ be a finite non-empty set of symbols such that $|\CIdU| \leqslant |\EvtU|$.

, and (blah) as above. The order-preserving union $\Merge: \EvtU^3 \times \EvtU^3 \to \EvtU^3$ of losets is computed as follows: $(\EvtU', \prec') \Merge (\EvtU'', \prec'') = \left(\EvtU' \cup \EvtU'', \prec \cap\, (\EvtU'\cup\EvtU'')^2\right)$.

    

%
We assume that every event be associated with a \emph{case identifier} $\CId \in \CIdU$ via a total surjective function $\CIdF: \EvtU \to \CIdU$ such that the restriction $\prec_\CId \,=\, \prec \cap \{ \Evt \in \EvtU: \CIdF(\Evt) = \CId \}^2$ of total order $\prec$ on all events mapped to the same $\CId$ is strict (i.e., if $\Evt \prec \Evt'$ with $\Evt \neq \Evt'$ and $\CIdF(\Evt) = \CIdF(\Evt')$ then $\Evt' \npreceq \Evt$).
%
In the example, \ldots\todo{Add example}
%
In other words, $\CIdF$ acts as an equivalence relation partitioning $\EvtU$ into $\left\{ \EvtU_\CId \right\}_{\CId \in \CIdU} \subseteq 2^{\EvtU}$ based on the {\CId} to which the events $\Evt \in \EvtU_\CId$ map, and imposing that events are linearly ordered by the restriction of $\prec$ on every $\EvtU_\CId$.
Every pair $\left( \EvtU_\CId, \prec_\CId \right)$ thus represents a finite linearly totally ordered set (or \emph{loset} for brevity) with $\EvtU_\CId \subseteq \EvtU$ and $\prec_\CId \;\subseteq \EvtU_\CId \times \EvtU_\CId \subseteq\; \prec \;\subseteq \EvtU \times \EvtU$.
Let $\left(\EvtU, \prec\right)$ be a loset and $(\EvtU', \prec')$, $(\EvtU'', \prec'')$ two (sub-)losets such that $\EvtU' \cup \EvtU'' \subseteq \EvtU$ and $\EvtU' \cap \EvtU'' = \emptyset$, with $\prec'$ and $\prec''$ being the restrictions of $\prec$ on $\EvtU'$ and $\EvtU''$, respectively:
$\prec' \triangleq \prec \cap \, \EvtU' \times \EvtU'$ and $\prec'' \triangleq \prec \cap \, \EvtU'' \times \EvtU''$.
\begin{definition}[Order-preserving union]\label{def:order-prev:union}
Let $\prec$ be a finite linear order defined over $\EvtU$, and (blah) as above. The order-preserving union $\Merge: \EvtU^3 \times \EvtU^3 \to \EvtU^3$ of losets is computed as follows: $(\EvtU', \prec') \Merge (\EvtU'', \prec'') = \left(\EvtU' \cup \EvtU'', \prec \cap\, (\EvtU'\cup\EvtU'')^2\right)$.
\end{definition}
%
We can thus derive the notion of case $\Case_\CId$ given a $\CId \in \CIdU$ as a loset of events mapping to the same $\CId$ and ordered by the linear restriction $\prec$ of $\prec$ over the events in $\Case_\CId$: $\Case_\CId=\left(\EvtU_\CId, \prec\right)$ where $\Case_\CId = \langle \Evt_1, \ldots, \Evt_{|\Case_\CId|} \rangle$ where $\CIdF(\Evt_i) = \CId \in \CIdU$ for every $i$ s.t.\ $ 1 \leqslant i \leqslant |\Case_\CId|$ and $e_i \prec e_j$ for every $ i \leq j \leqslant |\Case_\CId|$.%
\footnote{We employ the angular-bracket notation here for the sake of simplicity, although it is typically used for sequences. Unlike sequences, cases do not allow for the same event to occur more than once.}
Notice that the cardinality of $\CasU$ and $\CIdU$ coincide.
%
Events are also the domain of a function $\LPrvF: \EvtU \to \LPrvS$ mapping events to log provisioners.
In the example, \ldots\todo{Add example}
We shall denote with $\CasP_\CId$ the loset consisting of every event $\Evt \in \Case_\CId$ such that $\LPrvF(\Evt) = \LPrv$, with the restriction of the strict total order of $\Case_\CId$ on those events.
In the example, \ldots\todo{Add example}
\todo[inline]{Gotta move this one earlier when we introduce the example with the partitioned event log. (Section 4.2??). Clarify the difference between segmentation (given a segsize, i.e., a segment of a case-part in a sublog) and partitioning (of a log into case-parts of sublogs. Then, prove that the pipeline of partitioning and segmentation has its inverse in the union and merge for soundness.} 
%\end{comment}
%
\end{comment}
\end{newj}