\begin{newj}
Thus far, we have intuitively introduced the concepts of events, (partial) cases, (partial) traces, event logs and related aspects.
In this section, we delve deeper into these notions from a formal standpoint. The definitions provided henceforward pave the ground for properties and aspects to which we will resort in the design and realization of our solution.
\todo{Consider using \textbf{Definition} environments.}

\begin{definition}[Event]\label{def:evt}
	Let $\EvtU \ni \Evt$ be a finite non-empty set of symbols. We refer to $\Evt$ as \emph{event} and to $\EvtU$ as the \emph{universe of events}.
	An \emph{attribute} is a function having the universe of events as its domain.
\end{definition}
%
In the example, \ldots\todo{Add example}
Due to the general nature of elements that can be linked to events via the attribute function, we leave the range unspecified, akin to the definition of finite sequence as a function in \cite{Mendelson/2015:IntroductionMathematicalLogic}. We assume the following attributes as mandatory, though, as in the classical process mining literature~\cite{Aalst/2016:ProcessMiningBook:DataScienceinAction}.
%
\begin{assumption}[Mandatory attributes]\label{asm:attribute}
	The following attributes are total on the universe of events $\EvtU$:
	\begin{inparadesc}
		\item[instance identifier] (or {\CId} for short), a total surjective function $\CIdF : \EvtU \to \CIdU$, where $\CIdU$ is a finite non-empty set we name \emph{instance set};
		\item[activity label\textnormal{,}] a total function $\ActF : \EvtU \to \ActS$, where $\ActS$ is a finite non-empty set we name \emph{activity set};
		\item[timestamp\textnormal{,}] a total function $\TimeF : \EvtU \to \mathbb{N}$, where $\mathbb{N}$ is the set of positive integers.
	\end{inparadesc}
\end{assumption}

\begin{definition}[Event log]\label{def:evt:log}
	Given the universe of events $\EvtU$ as per \cref{def:evt}, let ${\prec \;\subseteq\; \EvtU \times \EvtU}$ be a strict total-order relation defined over $\EvtU$.
	The pair $\left( \EvtU, \prec \right)$ is an \emph{event log}.
\end{definition}
%
In the example,\todo{Add example here}
%
\begin{assumption}[Timestamp as an order isomorphism]\label{asm:order:timestamp}
	Given an event log $\left( \EvtU, \prec \right)$, the timestamp attribute $\TimeF: \EvtU \to \mathbb{N}$ is an \textit{order isomorphism}, i.e., given $\Evt, \Evt' \in \EvtU$ with $\Evt \neq \Evt'$, $\Evt \prec \Evt'$ if and only if $\TimeF(\Evt) < \TimeF(\Evt')$.
\end{assumption}
%
In the example,\todo{Add example here}

In our setting, events may be recorded by different entities (e.g., the \Actor{Hospital}). We name these entities \emph{provisioners} and formally define them as follows.
\begin{definition}[Provisioner]\label{def:provisioner}
	$\LPrvS = \{ \LPrv_1, \ldots, \LPrv_n \}$ is a non-empty finite set of entities (with $n \in \mathbb{N}$) we name \emph{provisioner}s. 
	Given an event $\Evt \in \EvtU$ as per \cref{def:evt}, $\PartMap$ is a total surjective function over the domain of events $\EvtU$ and the range $\LPrvS$ of provisioners. Function $\PartMap$ defines an equivalence relation $\PartEq$ on $\EvtU$ (i.e., $\Evt \PartEq \Evt'$ iff $\Evt \PartMap \LPrv$ and $\Evt' \PartMap \LPrv$) and hence partitions $\EvtU$ into equivalence classes we denote with $\EqCls{\LPrv}$ for every $\LPrv \in \LPrvS$.
\end{definition}
%
In the example, \ldots\todo{Add example}

\begin{definition}[Log partition]\label{def:partition}
	Given an event log $\left( \EvtU, \prec \right)$ as per \cref{def:evt:log}, provisioner $\LPrv \in \LPrvS$ and the equivalence class $\EqCls{\LPrv}$ as per \cref{def:provisioner}, a \emph{log partition} is a pair $\left( \EqCls{\LPrv}, \prec_\LPrv \right)$, where $\prec_\LPrv$ is the restriction of the total order $\prec$ over the elements in $\EqCls{\LPrv} \subseteq \EvtU$, i.e., $\;\prec_\LPrv$ is $(\prec) \cap (\EqCls{\LPrv} \times \EqCls{\LPrv})$.
\end{definition}
%
We recall that the restriction of a totally ordered set (like the event log) is a total order. Therefore, the log partition is a totally ordered set, too. In the example, \ldots\todo{Add example}

\begin{definition}[Segment]\label{def:segment}
	Given a log partition $\left( \EqCls{\LPrv}, \prec_\LPrv \right)$ as per \cref{def:partition} and a subset of {\CId}s $\{\CId_i\}_{i \in [1,k]}$ (see \cref{def:evt}) with $k \leq |\CIdU|$, $k \in \mathbb{N}$, $\CId_i \in \CIdU$, a \emph{segment} $\Segm = \left( \EvtU_\Segm, \prec_\Segm \right)$ is a restriction of the log partition to all the events $\Evt_\Segm \in \EqCls{\LPrv}$ such that $\CIdF(\Evt') = \CId_i$ for any $\CId_i$ in the given subset. 
\end{definition}
%
In light of the above, the log partition is a totally ordered set, too. Also, notice that a segment can be the whole log partition if the given set of {\CId}s contains all the {\CId}s to which the events in the log partition map. In the example, \ldots\todo{Add example}


\begin{definition}[Merge]\label{def:merge}
	Let $(\EvtU, \prec)$ be an event log, and
	${\Segm' = (\EvtU_{\Segm'}, \prec_{\Segm'})}$,
	${\Segm'' = (\EvtU_{\Segm''}, \prec_{\Segm''})}$ two segments thereof as per \cref{def:segment}. 
	The \emph{merge} $\Merge$ is a binary operator computed as follows: 
	$\Segm' \Merge \Segm'' = \left(\EvtU_{\Segm'} \cup \EvtU_{\Segm''}, \prec_{\Merge} \right)$ 
	where 
	$\prec_{\Merge}$ is the restriction of $\prec$ over $\EvtU_{\Segm'} \cup \EvtU_{\Segm''}$, i.e.,  $\prec \cap\, \left(\EvtU_{\Segm'} \cup \EvtU_{\Segm''}\right) \times \left(\EvtU_{\Segm'} \cup \EvtU_{\Segm''}\right)$. 
\end{definition}
%
We remark that \textbf{BALSDLADBASDBLADBLADJASBDBAJSD}
In light of the above, the log partition is a totally ordered set, too. In the example, \ldots\todo{Add example}

\begin{comment}
def iid(event):
  bla bla bla
  
caseid = iid
hospitalcaseid = iid
treatmentid = iid

comesichiama = {"hospital" : "caseid", "pharma" : "hospitalcaseid", "clinic" : "treatmentid"}

comesichiama["hospital"](x)
\end{comment}

	Let $\CIdU$ be a finite non-empty set of symbols such that $|\CIdU| \leqslant |\EvtU|$.

, and (blah) as above. The order-preserving union $\Merge: \EvtU^3 \times \EvtU^3 \to \EvtU^3$ of losets is computed as follows: $(\EvtU', \prec') \Merge (\EvtU'', \prec'') = \left(\EvtU' \cup \EvtU'', \prec \cap\, (\EvtU'\cup\EvtU'')^2\right)$.

%
We assume that every event be associated with a \emph{case identifier} $\CId \in \CIdU$ via a total surjective function $\CIdF: \EvtU \to \CIdU$ such that the restriction $\prec_\CId \,=\, \prec \cap \{ \Evt \in \EvtU: \CIdF(\Evt) = \CId \}^2$ of total order $\prec$ on all events mapped to the same $\CId$ is strict (i.e., if $\Evt \prec \Evt'$ with $\Evt \neq \Evt'$ and $\CIdF(\Evt) = \CIdF(\Evt')$ then $\Evt' \npreceq \Evt$).
%
In the example, \ldots\todo{Add example}
%
In other words, $\CIdF$ acts as an equivalence relation partitioning $\EvtU$ into $\left\{ \EvtU_\CId \right\}_{\CId \in \CIdU} \subseteq 2^{\EvtU}$ based on the {\CId} to which the events $\Evt \in \EvtU_\CId$ map, and imposing that events are linearly ordered by the restriction of $\prec$ on every $\EvtU_\CId$.
Every pair $\left( \EvtU_\CId, \prec_\CId \right)$ thus represents a finite linearly totally ordered set (or \emph{loset} for brevity) with $\EvtU_\CId \subseteq \EvtU$ and $\prec_\CId \;\subseteq \EvtU_\CId \times \EvtU_\CId \subseteq\; \prec \;\subseteq \EvtU \times \EvtU$.
Let $\left(\EvtU, \prec\right)$ be a loset and $(\EvtU', \prec')$, $(\EvtU'', \prec'')$ two (sub-)losets such that $\EvtU' \cup \EvtU'' \subseteq \EvtU$ and $\EvtU' \cap \EvtU'' = \emptyset$, with $\prec'$ and $\prec''$ being the restrictions of $\prec$ on $\EvtU'$ and $\EvtU''$, respectively:
$\prec' \triangleq \prec \cap \, \EvtU' \times \EvtU'$ and $\prec'' \triangleq \prec \cap \, \EvtU'' \times \EvtU''$.
\begin{definition}[Order-preserving union]\label{def:order-prev:union}
Let $\prec$ be a finite linear order defined over $\EvtU$, and (blah) as above. The order-preserving union $\Merge: \EvtU^3 \times \EvtU^3 \to \EvtU^3$ of losets is computed as follows: $(\EvtU', \prec') \Merge (\EvtU'', \prec'') = \left(\EvtU' \cup \EvtU'', \prec \cap\, (\EvtU'\cup\EvtU'')^2\right)$.
\end{definition}
%
We can thus derive the notion of case $\Case_\CId$ given a $\CId \in \CIdU$ as a loset of events mapping to the same $\CId$ and ordered by the linear restriction $\prec$ of $\prec$ over the events in $\Case_\CId$: $\Case_\CId=\left(\EvtU_\CId, \prec\right)$ where $\Case_\CId = \langle \Evt_1, \ldots, \Evt_{|\Case_\CId|} \rangle$ where $\CIdF(\Evt_i) = \CId \in \CIdU$ for every $i$ s.t.\ $ 1 \leqslant i \leqslant |\Case_\CId|$ and $e_i \prec e_j$ for every $ i \leq j \leqslant |\Case_\CId|$.%
\footnote{We employ the angular-bracket notation here for the sake of simplicity, although it is typically used for sequences. Unlike sequences, cases do not allow for the same event to occur more than once.}
Notice that the cardinality of $\CasU$ and $\CIdU$ coincide.
%
Events are also the domain of a function $\LPrvF: \EvtU \to \LPrvS$ mapping events to log provisioners.
In the example, \ldots\todo{Add example}
We shall denote with $\CasP_\CId$ the loset consisting of every event $\Evt \in \Case_\CId$ such that $\LPrvF(\Evt) = \LPrv$, with the restriction of the strict total order of $\Case_\CId$ on those events.
In the example, \ldots\todo{Add example}
\todo[inline]{Gotta move this one earlier when we introduce the example with the partitioned event log. (Section 4.2??). Clarify the difference between segmentation (given a segsize, i.e., a segment of a case-part in a sublog) and partitioning (of a log into case-parts of sublogs. Then, prove that the pipeline of partitioning and segmentation has its inverse in the union and merge for soundness.} 
%\end{comment}
%
\end{newj}